<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>场景图-坦克</title>
  <style>
    html,body{
      margin: 0;
      height: 100%;
    }
    #c{
      width:100%;
      height: 100%;
      display: block;
    }
    #info {
      position: absolute;
      left: 1em;
      top: 1em;
      background: rgba(0,0,0,.8);
      padding: .5em;
      color: white;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="info"></div>
  <script type="importmap">
    {
      "imports":{
        "three":"./node_modules/three/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three'
    function main(){
      const canvas=document.getElementById('c');
      const renderer=new THREE.WebGLRenderer({canvas})
      renderer.setClearColor(0xaaaaaa,.5) //设置颜色及其透明度
      renderer.shadowMap.enabled=true //shadowMap如果使用，它包含阴影贴图的引用，enabled如果设置开启，允许在场景中使用阴影贴图

      function makeCamera(fov=40){
        const aspect=2
        const near=0.1
        const far=1000
        return new THREE.PerspectiveCamera(fov,aspect,near,far)
      } 

      const camera=makeCamera();
      // camera.position.set(8,4,10).mutiplyScalar(3)
      camera.position.set(8, 4, 10).multiplyScalar(3);
      camera.lookAt(0,0,0) //旋转物体使其在世界空间中面朝一个点

      const scene=new THREE.Scene()

      {
        const light=new THREE.DirectionalLight(0xffffff,1)
        light.position.set(0,20,0)
        scene.add(light)
        light.castShadow=true //castShadow 对象是否被渲染到阴影贴图中
        light.shadow.mapSize.width=2048
        light.shadow.mapSize.height=2048

        const d=50
        light.shadow.camera.left=-d
        light.shadow.camera.right=d
        light.shadow.camera.top=d
        light.shadow.camera.bottom=-d
        light.shadow.camera.near=1
        light.shadow.camera.far=50
        light.shadow.bias=0.001 //bias 阴影贴图偏差
      }
      {
        const light=new THREE.DirectionalLight(0xffffff,1)
        light.position.set(1,2,4)
        scene.add(light)
      }

      const groundGeometry=new THREE.PlaneGeometry(50,50)
      const groundMaterial=new THREE.MeshPhongMaterial({color:0xcc8866})
      const groundMesh=new THREE.Mesh(groundGeometry,groundMaterial)
      groundMesh.rotation.x=Math.PI * -.5
      groundMesh.receiveShadow=true //材质是否接受阴影
      scene.add(groundMesh)

      const carWidth=4;
      const carHeight=1;
      const carLength=8;

      const tank=new THREE.Object3D()
      scene.add(tank)

      const bodyGeometry=new THREE.BoxGeometry(carWidth,carHeight,carLength)
      const bodyMaterial=new THREE.MeshPhongMaterial({color:0x6688aa})
      const bodyMesh=new THREE.Mesh(bodyGeometry,bodyMaterial)
      bodyMesh.position.y=1.4
      bodyMesh.castShadow=true //对象是否渲染在阴影中
      tank.add(bodyMesh)

      const tankCameraFov=75
      const tankCamera=makeCamera(tankCameraFov)
      tankCamera.position.y=3
      tankCamera.position.z=-6
      tankCamera.rotation.y=Math.PI
      bodyMesh.add(tankCamera)

      const wheelRadius=1
      const wheelThickness=.5
      const wheelSegments=6
      const wheelGeometry=new THREE.CylinderGeometry(wheelRadius,wheelRadius,wheelThickness,wheelSegments)
      const wheelMaterial=new THREE.MeshPhongMaterial({color:0x888888})
      const wheelPositions=[
        [-carWidth / 2 - wheelThickness / 2, -carHeight / 2,  carLength / 3],
        [ carWidth / 2 + wheelThickness / 2, -carHeight / 2,  carLength / 3],
        [-carWidth / 2 - wheelThickness / 2, -carHeight / 2, 0],
        [ carWidth / 2 + wheelThickness / 2, -carHeight / 2, 0],
        [-carWidth / 2 - wheelThickness / 2, -carHeight / 2, -carLength / 3],
        [ carWidth / 2 + wheelThickness / 2, -carHeight / 2, -carLength / 3],
      ]
      const wheelMeshes=wheelPositions.map((position)=>{
        const mesh=new THREE.Mesh(wheelGeometry,wheelMaterial)
        mesh.position.set(...position)
        mesh.rotation.z=Math.PI*.5
        mesh.castShadow=true //对象是否渲染在阴影中
        bodyMesh.add(mesh)
        return mesh
      })

      const domeRadius = 2;
      const domeWidthSubdivisions = 12;
      const domeHeightSubdivisions = 12;
      const domePhiStart = 0;
      const domePhiEnd = Math.PI * 2;
      const domeThetaStart = 0;
      const domeThetaEnd = Math.PI * .5;
      const domeGeometry=new THREE.SphereGeometry(domeRadius,domeWidthSubdivisions,domeHeightSubdivisions,domePhiStart,domePhiEnd,domeThetaStart,domeThetaEnd)
      const domeMesh=new THREE.Mesh(domeGeometry,bodyMaterial)
      domeMesh.castShadow=true;
      bodyMesh.add(domeMesh);
      domeMesh.position.y=.5

      const turretWidth = .1;
      const turretHeight = .1;
      const turretLength = carLength * .75 * .2;
      const turretGeometry=new THREE.BoxGeometry(turretWidth,turretHeight,turretLength)
      const turretMesh=new THREE.Mesh(turretGeometry,bodyMaterial)
      const turretPivot=new THREE.Object3D()
      turretMesh.castShadow=true
      turretPivot.scale.set(5,5,5)
      turretPivot.position.y=.5
      turretMesh.position.z=turretLength*.5
      turretPivot.add(turretMesh)
      bodyMesh.add(turretPivot)

      const turretCamera=makeCamera()
      turretCamera.position.y=.75*.2
      turretMesh.add(turretCamera)

      const targetGeometry=new THREE.SphereGeometry(.5,6,3)
      const targetMaterial=new THREE.MeshPhongMaterial({color:0x00ff00,flatShading:true}) //flatshading 定义材质是否使用平面着色进行渲染
      const targetMesh=new THREE.Mesh(targetGeometry,targetMaterial)
      const targetOrbit=new THREE.Object3D()
      const targetElevation=new THREE.Object3D()
      const targetBob=new THREE.Object3D()
      targetMesh.castShadow=true
      scene.add(targetOrbit)
      targetOrbit.add(targetElevation)
      targetElevation.position.z=carLength*2
      targetElevation.position.y=8
      targetElevation.add(targetBob)
      targetBob.add(targetMesh)

      const targetCamera = makeCamera();
      const targetCameraPivot = new THREE.Object3D();
      targetCamera.position.y = 1;
      targetCamera.position.z = -2;
      targetCamera.rotation.y = Math.PI;
      targetBob.add(targetCameraPivot);
      targetCameraPivot.add(targetCamera);

      const curve = new THREE.SplineCurve( [
        new THREE.Vector2( -10, 0 ),
        new THREE.Vector2( -5, 5 ),
        new THREE.Vector2( 0, 0 ),
        new THREE.Vector2( 5, -5 ),
        new THREE.Vector2( 10, 0 ),
        new THREE.Vector2( 5, 10 ),
        new THREE.Vector2( -5, 10 ),
        new THREE.Vector2( -10, -10 ),
        new THREE.Vector2( -15, -8 ),
        new THREE.Vector2( -10, 0 ),
      ] );

      const points = curve.getPoints( 50 );
      const geometry = new THREE.BufferGeometry().setFromPoints( points );
      const material = new THREE.LineBasicMaterial( { color : 0xff0000 } );
      const splineObject = new THREE.Line( geometry, material );
      splineObject.rotation.x = Math.PI * .5;
      splineObject.position.y = 0.05;
      scene.add(splineObject);

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      const targetPosition=new THREE.Vector3()
      const tankPosition=new THREE.Vector2()
      const tankTarget=new THREE.Vector2()

      const cameras=[
        { cam: camera, desc: 'detached camera', },
        { cam: turretCamera, desc: 'on turret looking at target', },
        { cam: targetCamera, desc: 'near target looking at tank', },
        { cam: tankCamera, desc: 'above back of tank', },
      ]

      const infoElem = document.getElementById('info');

      function render(time){
        time*=0.001;
        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          cameras.forEach((cameraInfo) => {
            const camera = cameraInfo.cam;
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
          });
        }

        //移动目标
        targetOrbit.rotation.y=time*.27
        targetBob.position.y=Math.sin(time*2)*4
        targetMesh.rotation.x=time * 7
        targetMesh.rotation.y=time * 13
        targetMaterial.emissive.setHSL(time * 10 % 1,1,.25)
        targetMaterial.color.setHSL(time * 10 % 1,1,.25)

        //移动坦克
        const tankTime=time * .05
        curve.getPointAt(tankTime % 1, tankPosition) //参数1-根据弧长确定在曲线上的位置，必须在[0,1]范围内。参数2-（可选）如果需要，结果将复制到此向量中
        curve.getPointAt((tankTime + 0.01) % 1, tankTarget)
        tank.position.set(tankPosition.x,0,tankPosition.y)
        tank.lookAt(tankTarget.x,0,tankTarget.y)

        //面向塔台的目标
        targetMesh.getWorldPosition(targetPosition) //结果将被复制到这个Vector3中，返回一个表示该物体在世界空间中位置的矢量
        turretPivot.lookAt(targetPosition)

        //让这个炮塔的相机看向这个目标
        turretCamera.lookAt(targetPosition)

        //让这个目标相机的轴点看向这个坦克
        tank.getWorldPosition(targetPosition)
        targetCameraPivot.lookAt(targetPosition)

        wheelMeshes.forEach(obj=>{
          obj.rotation.x=time*3
        })

        const camera=cameras[time * .25 % cameras.length | 0]
        infoElem.textContent=camera.desc

        renderer.render(scene,camera.cam)

        requestAnimationFrame(render)
      }

      requestAnimationFrame(render)
    }

    main();
    
  </script>
</body>
</html>